{
    "collab_server" : "",
    "contents" : "#####################################################################\n# Predict next word regex vFinal using the backoff implementation with incomplete\n#   and the knersey-ney probabilities already calculated previously:\n#\n#             DT_uni_prob.Rdata: data table that include all the unigrams \n#                       frequency and the knersey-ney prob\n#             DT_bi_prob.Rdata: data table that include all the bigrams \n#                       frequency and the knersey-ney prob\n#             DT_tri_prob.Rdata: data table that include all the trigrams \n#                       frequency and the knersey-ney prob\n#             DT_quad_prob.Rdata: data table that include all the quadgrams \n#                       frequency and the knersey-ney prob\n\nlibrary(data.table)\n\n#setwd(\"D:/Coursera/Capstone Project/Coursera-SwiftKey/final/en_US\")\n#setwd(\"D:/001 -- Coursera/Capstone Project/Coursera-SwiftKey/final/en_US\")\n\n# For reproducibility\nset.seed(12345)\n\nelapsed_time <- function(tic1,tic2) {\n  format((tic2-tic1)[3][[1]], digits = 2)\n}\n\n\ntopn_predict_regex <- function(x,p=0,n=5,f=1) {\n  # f is the factor\n  \n  \n  print(paste(\"-----> topn_predict_regex(\",\n              \" word:=(\",paste(x, collapse=\",\"),\")\",\n              \", prob:=\",p,\n              \", nun_words:=\",n,\n              \", factor:=\",f,\n              \").......\",sep=\"\"))\n  \n  \n  #print(paste(\"-----> topn_predict(\",x,\",\",p,\",\",n,\",\",f,\").......\",sep=\"\"))\n  t1 <- proc.time()\n  topn <- NULL\n  \n  l <- length(x)\n  \n  if (l == 1) {\n    #uni-gram level, let's check the unigram table for the regex and apply the factor for backoff\n\n    regex_word <- paste(\"^\",x[1],\".\",sep=\"\")\n    \n    topn <- DT.uni.prob[grepl(regex_word,t1),,]\n    topn <- topn[head(order(-prob),n)] \n    topn[,word:=t1,] \n    topn <- topn[,list(word,prob),]\n\n    num_words <- nrow(topn)\n    \n    print(paste(\"...Found:\",num_words,\" words ...\"))\n    print(topn)\n  } else if (l == 2) {\n    #bi-gram level, let's check the unigram table for the regex and apply the factor for backoff\n    \n    regex_word <- paste(\"^\",x[2],\".\",sep=\"\")\n    \n    topn <- DT.bi.prob[t1 == x[1],,]\n    topn <- topn[grepl(regex_word,t2),,]\n    \n    topn <- topn[head(order(-prob),n)] \n    topn[,word:=t2,] \n    topn <- topn[,list(word,prob),]\n    \n    num_words <- nrow(topn)\n    \n    print(paste(\"...Found:\",num_words,\" words ...\"))\n    print(topn)\n    \n\n    if (num_words < n) {\n      print(paste(\"... Backoff to Unigram Level with factor:\",0.4*f))\n      topn <- rbind(topn,topn_predict_regex(c(x[2]),p,n,0.4*f))\n    }\n  }  else if (l == 3) {\n    #tri-gram level, let's check the trigram table for the regex and apply the factor for backoff\n    \n    regex_word <- paste(\"^\",x[3],\".\",sep=\"\")\n    \n    topn <- DT.tri.prob[t1 == x[1] & t2 == x[2],,]\n    topn <- topn[grepl(regex_word,t3),,]\n    \n    topn <- topn[head(order(-prob),n)] \n    topn[,word:=t3,] \n    topn <- topn[,list(word,prob),]\n    \n    num_words <- nrow(topn)\n    \n    print(paste(\"...Found:\",num_words,\" words ...\"))\n    print(topn)\n    \n    \n    if (num_words < n) {\n      print(paste(\"... Backoff to Bigram Level with factor:\",0.4*f))\n      topn <- rbind(topn,topn_predict_regex(c(x[2],x[3]),p,n,0.4*f))\n    }\n  } else if (l == 4) {\n    #quad-gram level, let's check the quadgram table for the regex and apply the factor for backoff\n    \n    regex_word <- paste(\"^\",x[4],sep=\"\")\n    \n    topn <- DT.quad.prob[t1 == x[1] & t2 == x[2] & t3 == x[3],,]\n    topn <- topn[grepl(regex_word,t4),,]\n    \n    topn <- topn[head(order(-prob),n)] \n    topn[,word:=t4,] \n    topn <- topn[,list(word,prob),]\n    \n    num_words <- nrow(topn)\n    \n    print(paste(\"...Found:\",num_words,\" words ...\"))\n    print(topn)\n    \n    \n    if (num_words < n) {\n      print(paste(\"... Backoff to Trigram Level with factor:\",0.4*f))\n      topn <- rbind(topn,topn_predict_regex(c(x[2],x[3],x[4]),p,n,0.4*f))\n    }\n  }\n  t2 <- proc.time()\n  \n  print(paste(\"-----> topn_predict_regex: Running Time .......\",\n              elapsed_time(t1,t2),\" seconds ...\",sep=\"\"))\n  \n  topn\n}\n\n\npredict_nextword_regex <- function(x,lines=-1,p=0,n=5) {\n  \n  l <- length(x)\n  \n  load_DT_prob_table(1,lines)\n  load_DT_prob_table(2,lines)\n  load_DT_prob_table(3,lines)\n  load_DT_prob_table(4,lines)\n  \n  print(paste(\"-----> predict_nextword_regex(\",\n              \" word:=(\",paste(x, collapse=\",\"),\")\",\n              \", lines:=\",lines,\n              \", prob:=\",p,\n              \", n:=\",n,\n              \").......\",sep=\"\"))\n  t1 <- proc.time()\n  \n  result <- topn_predict_regex(x,p,n,1)\n\n  t2 <- proc.time()\n  print(paste(\"-----> predict_nextword_regex: Running Time .......\",\n              elapsed_time(t1,t2),\" seconds ...\",sep=\"\"))\n  \n  # Remove duplicated values, some words could appers duplicated as a part of\n  # backoff strategy\n  setkey(result,word)\n  result <- unique(result)\n  result[head(order(-prob),n)]\n\n}  \n\n\n",
    "created" : 1467119901776.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "976441464",
    "id" : "4DBBFCF6",
    "lastKnownWriteTime" : 1467119913,
    "last_content_update" : 1467119913252,
    "path" : "D:/Coursera/Capstone Project/Coursera---Data-Science---Capstone-Project/Pred Next Word Regex vFinal.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}