{
    "collab_server" : "",
    "contents" : "#####################################################################\n# Knersey-ney VFinal\n# Calculate Knersey-ney of the differents ngrams (unigram, bigram, trigram and quadgrams)\n#          to be used later with Kneser-ney algortihm to calculate the\n#          probability of each ngram for predict the next word.\n#          This script was run on my PC and takes long time to finish,\n#          at the end this script saves the data into four files:\n#\n#             uni_dt.Rdata: data frame that include all the unigrams and the\n#                          frequency for each one.\n#             bi_dt.Rdata: data frame that include all the bigrams and the\n#                          frequency for each one.\n#             tri_dt.Rdata: data frame that include all the trigrams and the\n#                          frequency for each one.\n#             quad_dt.Rdata: data frame that include all the quadgrams and the\n#                          frequency for each one.\n# In this version we did some optimizations related with the recursion.\n# We start calculating the unigrams probability. This calculation could be used\n# on bigrams calculations. To do that we also store lambda(x). \n\nlibrary(data.table)\n\nsetwd(\"D:/Coursera/Capstone Project/Coursera-SwiftKey/final/en_US\")\n#setwd(\"D:/001 -- Coursera/Capstone Project/Coursera-SwiftKey/final/en_US\")\n\n# For reproducibility\nset.seed(12345)\n\nelapsed_time <- function(tic1,tic2) {\n  format((tic2-tic1)[3][[1]], digits = 2)\n}\n\ncreate_filename <- function(x,lines) {\n  \n  if (lines < 0) {\n    paste(x,\"_all.RData\",sep= \"\")\n  }\n  else {\n    paste(x,\"_\",lines,\".RData\",sep= \"\")\n  }\n}\n\nload_DT_table <- function (n,lines=-1) {\n  \n  if (n == 1) {\n    var.name <- \"DT.uni\"\n    file.name <- create_filename(\"DT_uni\",lines)\n  } else if (n == 2) {\n    var.name <- \"DT.bi\"\n    file.name <- create_filename(\"DT_bi\",lines)\n  } else if (n == 3) {\n    var.name <- \"DT.tri\"\n    file.name <- create_filename(\"DT_tri\",lines)\n  } else if (n == 4) {\n    var.name <- \"DT.quad\"\n    file.name <- create_filename(\"DT_quad\",lines)\n  }\n  \n  #Validate if the DT exists in the enviroment\n  if (!exists(var.name)) {\n    #Validate if the file exists an load the value\n    if (file.exists(file.name)) {\n      print(paste(\"-----> load_DT_table(\",n,\").......\",sep=\"\"))\n      t1 <- proc.time()\n      \n      print(paste(\"Loading DT file: \",file.name, sep =\"\"))\n      load(file.name,.GlobalEnv) \n      \n      print(paste(\"Creating DT Table from:\",var.name, sep =\"\"))\n      \n      if (n == 1) {\n        DT.uni <<- as.data.table(DT.uni, key = \"t1\")\n      } else if (n == 2) {\n        DT.bi <<- as.data.table(DT.bi, key = \"t1,t2\")\n      } else if (n == 3) {\n        DT.tri <<- as.data.table(DT.tri, key = \"t1,t2,t3\")\n      } else if (n == 4) {\n        DT.quad <<- as.data.table(DT.quad, key = \"t1,t2,t3,t4\")\n      }\n      t2 <- proc.time()\n      print(paste(\"-----> load_DT_table: Running Time .......\",\n                  elapsed_time(t1,t2),\" seconds ...\",sep=\"\"))\n      \n    }\n    else {\n      # Error file doesn't exists\n      print(paste(\"Error file doesnt exist:\",file.name, sep=\"\"))\n    }\n  }\n}\n\n\ninit_DT_table <- function (n,lines=-1,p1=5) { \n\n  # Values needed for Knersey-prob\n  p1 <<- p1\n  p2 <<- p1 + 1\n  \n  if (n == 1) {\n    file.name <- create_filename(\"DT_uni_prob_temp\",lines)\n  } else if (n == 2) {\n    var.name <- \"DT.bi.prob\"\n    file.name <- create_filename(\"DT_bi_prob_temp\",lines)\n  } else if (n == 3) {\n    file.name <- create_filename(\"DT_tri_prob_temp\",lines)\n  } else if (n == 4) {\n    file.name <- create_filename(\"DT_quad_prob_temp\",lines)\n  }\n  \n  #Validate if exists a DT probability temporal table\n  if (file.exists(file.name)) {\n    print(paste(\"Loading DT with probability temporal file: \",file.name, sep =\"\"))\n    load(file.name,.GlobalEnv) \n  } else {\n    \n    # Init DT table\n    print(paste(\"-----> init_DT_table(\",n,\",\",p1,\").......\",sep=\"\"))\n    t1 <- proc.time()\n    \n    if (n==1) {\n      DT.uni <<- DT.uni[freq >= p1,,]\n      DT.uni[,n11:=-1,]\n      DT.uni[,n12:=-1,]\n      DT.uni[,l1:=-1,]\n      DT.uni[,l2:=-1,]\n      DT.uni[,a1:=-1,]\n      DT.uni[,a2:=-1,]\n      DT.uni[,pkn1:=-1,]\n      DT.uni[,pkn2:=-1,]\n      \n    } else if (n==2) {\n      DT.bi <<- DT.bi[freq >= p1,,]\n      DT.bi[,n11:=-1,]\n      DT.bi[,n12:=-1,]\n      DT.bi[,l1:=-1,]\n      DT.bi[,l2:=-1,]\n      DT.bi[,pkn1:=-1,]\n      DT.bi[,pkn2:=-1,]\n      DT.bi[,a1:=-1,]\n      DT.bi[,a2:=-1,]\n      \n    } else if (n==3) {\n      DT.tri <<- DT.tri[freq >= p1,,]\n      DT.tri[,n11:=-1,]\n      DT.tri[,n12:=-1,]\n      DT.tri[,l1:=-1,]\n      DT.tri[,l2:=-1,]\n      DT.tri[,pkn1:=-1,]\n      DT.tri[,pkn2:=-1,]\n      DT.tri[,a1:=-1,]\n      DT.tri[,a2:=-1,]\n      \n    } else if (n==4) {\n      DT.quad <<- DT.quad[freq >= p1,,]\n      DT.quad[,n11:=-1,]\n      DT.quad[,n12:=-1,]\n      DT.quad[,l1:=-1,]\n      DT.quad[,l2:=-1,]\n      DT.quad[,pkn1:=-1,]\n      DT.quad[,pkn2:=-1,]\n      DT.quad[,a1:=-1,]\n      DT.quad[,a2:=-1,]\n      \n    }\n    t2 <- proc.time()\n    \n    \n    \n    print(\"-----> init_DT_table: Running Time .......\")\n    print(t2 - t1)\n  }\n  \n  if (n == 1) {\n    n.uni <<- nrow(DT.uni)\n\n  } else if (n ==2) {\n    n.bi <<- nrow(DT.bi)\n    ######### Discount values (D1, D2, D3) for lambda function\n    #\n    #   n1: number of ngrams that occurs exactly one time\n    #   n2: number of ngrams that occurs exactly two times\n    #    D1 = n1 / (n1 + 2 * n2)\n    \n    n1.bi <<- nrow(DT.bi[freq == p1,,])\n    n2.bi <<- nrow(DT.bi[freq == p2,,])\n    D2 <<- n1.bi / (n1.bi + 2 * n2.bi) \n  } else if (n==3) {\n    n.tri <<- nrow(DT.tri)\n    ######### Discount values (D1, D2, D3) for lambda function\n    #\n    #   n1: number of ngrams that occurs exactly one time\n    #   n2: number of ngrams that occurs exactly two times\n    #    D1 = n1 / (n1 + 2 * n2)\n    \n    n1.tri <<- nrow(DT.tri[freq == p1,,])\n    n2.tri <<- nrow(DT.tri[freq == p2,,])\n    D3 <<- n1.tri / (n1.tri + 2 * n2.tri) \n  } else if (n==4) {\n    n.quad <<- nrow(DT.quad)\n    ######### Discount values (D1, D2, D3) for lambda function\n    #\n    #   n1: number of ngrams that occurs exactly one time\n    #   n2: number of ngrams that occurs exactly two times\n    #    D1 = n1 / (n1 + 2 * n2)\n    #    \n    \n    n1.quad <<- nrow(DT.quad[freq == p1,,])\n    n2.quad <<- nrow(DT.quad[freq == p2,,])\n    D4 <<- n1.quad / (n1.quad + 2 * n2.quad) \n  }\n  \n}\n  \n  \n\ninit_DT_tables <- function (lines=-1,p1=5) { \n  \n  print(paste(\"-----> init_DT_tables(\",p1,\").......\",sep=\"\"))\n  t1 <- proc.time()\n\n  ## Load and init the DT table  \n  load_DT_table(1,lines)\n  init_DT_table(1,lines,p1)\n  \n  load_DT_table(2,lines)\n  init_DT_table(2,lines,p1)\n  \n  load_DT_table(3,lines)\n  init_DT_table(3,lines,p1)\n  \n  load_DT_table(4,lines)\n  init_DT_table(4,lines,p1)\n  \n  t2 <- proc.time()\n  \n  print(paste(\"-----> init_DT_tables: Running Time .......\",\n              elapsed_time(t1,t2),\" seconds ...\",sep=\"\"))\n}\n\nN1plus_pre <- function(x) {\n  # Count the number of unique words that precede the n-gram x \n  # with at least 1 appareance.\n  #\n  # Parameters:\n  #   x:  n-gram to be considered, with the following format\n  #       c(\"t1\") # unigram\n  #       c(\"t1\",t2\") # bigram\n  #   l:  integer that identified the type of x\n  #       1 #unigram\n  #       2 #bigram\n  #   dt: data table that have the frequency for each ngram\n  #     for bigrams:\n  #     c(\"t1\",\"t2\",\"freq\",\"prob\") # bigram\n  #     c(\"t1\",\"t2\",\"t3\",\"freq\",\"prob\") # trigram\n  \n  l <- length(x)\n  r <- -1\n  if (l == 1) {\n    ## Count the predecessor words in bigram table\n    #Check if the value doesn't exists and calculate it\n    r <- DT.uni[t1 == x[1],n11,]\n\n    if (r < 0) {\n      #nrow(bi.dt[which(bi.dt$t2 == x[1] & bi.dt$freq >= 1),])\n      r <- nrow(DT.bi[t2 == x[1] & freq >= 1,,])\n      DT.uni[t1 == x[1],n11:=r,]\n    }\n    \n  } else if (l == 2) {\n    ## Count the predecessor words in trigram table\n    \n    #nrow(tri.dt[which(tri.dt$t2 == x[1] &\n    #                    tri.dt$t3 == x[2] &\n    #                    tri.dt$freq >=1 ),])\n    r <- DT.bi[t1 == x[1] & t2 == x[2],n11,]\n    if (r < 0) {\n      r <- nrow(DT.tri[t2 == x[1] & t3 == x[2] & freq >= 1,,])\n      DT.bi[t1 == x[1] & t2 == x[2],n11:=r,]\n    }      \n  } else if (l == 3) {\n    ## Count the predecessor words in quad table\n    \n    #nrow(quad.dt[which(quad.dt$t2 == x[1] &\n    #                     quad.dt$t3 == x[2] &\n    #                     quad.dt$t4 == x[3] &\n    #                     quad.dt$freq >=1 ),])\n    r <- DT.tri[t1 == x[1] & t2 == x[2] & t3 == x[3],n11,]\n    \n    if (r < 0) {\n      r <- nrow(DT.quad[t2 == x[1] & t3 == x[2] & t4 == x[3] & freq >= 1,,])\n      DT.tri[t1 == x[1] & t2 == x[2] & t3 == x[3],n11:=r,]\n    }\n  }\n  r\n}\n\n\n\nN1plus_suc <- function(x) {\n  # Count the number of unique words that succeed the n-gram x \n  # with at least 1 appareance.\n  #\n  # Parameters:\n  #   x:  n-gram to be considered, with the following format\n  #       c(\"t1\") # unigram\n  #       c(\"t1\",t2\") # bigram\n  #   l:  integer that identified the type of x\n  #       1 #unigram\n  #       2 #bigram\n  #   dt: data table that have the frequency for each ngram\n  #     for bigrams:\n  #     c(\"t1\",\"t2\",\"freq\",\"prob\") # bigram\n  #     c(\"t1\",\"t2\",\"t3\",\"freq\",\"prob\") # trigram\n  l <- length(x)\n  r <- -1\n  if (l == 1){\n    ## Count the succeed words in bigram table\n    \n    #nrow(bi.dt[which(bi.dt$t1 == x[1] & bi.dt$freq >= 1),])\n    \n    r <- DT.uni[t1 == x[1],n12,]\n    \n    if (r<0)\n    {\n      r <- nrow(DT.bi[t1 == x[1] & freq >= 1,,])\n      DT.uni[t1 == x[1],n12:=r,]\n    }\n    \n  } else if (l == 2) {\n    \n    ## Count the succeed words in trigram table\n    \n    #nrow(tri.dt[which(tri.dt$t1 == x[1] & \n    #                    tri.dt$t2 == x[2] &\n    #                    tri.dt$freq >=1 ),])\n    \n    r <- DT.bi[t1 == x[1] & t2 == x[2],n12,]\n    \n    if (r<0)\n    {\n      r <- nrow(DT.tri[t1 == x[1] & t2 == x[2] & freq >= 1,,])\n      DT.bi[t1 == x[1] & t2 == x[2],n12:=r,]\n    }\n    \n  } else if (l == 3) {\n    \n    ## Count the succeed words in quadgram table\n    \n    #nrow(quad.dt[which(quad.dt$t1 == x[1] & \n    #                     quad.dt$t2 == x[2] &\n    #                     quad.dt$t3 == x[3] &\n    #                     quad.dt$freq >=1 ),])\n    \n    r <-  DT.tri[t1 == x[1] & t2 == x[2] & t3 == x[3], n12,]\n    \n    if (r < 0) {\n      r <- nrow(DT.quad[t1 == x[1] & t2 == x[2] & t3 == x[3] & freq >= 1,,])\n      DT.tri[t1 == x[1] & t2 == x[2] & t3 == x[3], n12:=r,]\n    }\n    \n  }\n  r\n}\n\nngram_count <- function(x) {\n  # Count the number of times that the n-gram x appears on dt\n  # Parameters:\n  #   x:  n-gram to be considered, with the following format\n  #       c(\"t1\") # unigram\n  #       c(\"t1\",t2\") # bigram\n  #   l:  integer that identified the type of x\n  #       1 #unigram\n  #       2 #bigram\n  #   dt: data table that have the frequency for each ngram\n  #     for bigrams:\n  #     c(\"t1\",\"t2\",\"freq\",\"prob\") # bigram\n  #     c(\"t1\",\"t2\",\"t3\",\"freq\",\"prob\") # trigram\n  \n  l <- length(x)\n  if (l == 1) {\n    ## Provide the frequency of the ngram on unigram table\n    \n    #(uni.dt[which(uni.dt$t1 == x[1]),])$freq\n    \n    DT.uni[t1 == x[1],freq,]\n    \n  } else if (l == 2) {\n    ## Provide the frequency of the ngram on bigram table\n    \n    #(bi.dt[which(bi.dt$t1 == x[1] & \n    #               bi.dt$t2 == x[2]),])$freq\n    DT.bi[t1 == x[1] & t2 == x[2],freq,]\n    \n  } else if (l == 3) {\n    ## Provide the frequency of the ngram on trigram table\n    \n    #(tri.dt[which(tri.dt$t1 == x[1] & \n    #                tri.dt$t2 == x[2] &\n    #                tri.dt$t3 == x[3] ),])$freq\n    DT.tri[t1 == x[1] & t2 == x[2] & t3 == x[3],freq,]\n    \n  } else if (l == 4) {\n    ## Provide the frequency of the ngram on quadgram table\n    \n    #(quad.dt[which(quad.dt$t1 == x[1] & \n    #                 quad.dt$t2 == x[2] &\n    #                 quad.dt$t3 == x[3] &\n    #                 quad.dt$t4 == x[4]),])$freq\n    \n    DT.quad[t1 == x[1] & t2 == x[2] & t3 == x[3] & t4 == x[4],freq,]\n    \n  }\n  \n}\n\n\ncount_kn <- function(x,high_order) {\n  # Count the number of times that the n-gram x appears on dt\n  # Parameters:\n  #   x:  n-gram to be considered, with the following format\n  #       c(\"t1\") # unigram\n  #       c(\"t1\",t2\") # bigram\n  #   l:  integer that identified the type of x\n  #       1 #unigram\n  #       2 #bigram\n  #   dt: data table that have the frequency for each ngram\n  #     for bigrams:\n  #     c(\"t1\",\"t2\",\"freq\",\"prob\") # bigram\n  #     c(\"t1\",\"t2\",\"t3\",\"freq\",\"prob\") # trigram\n  \n  if (high_order) {\n    # For high order calculations, use ngram_count(x)\n    ngram_count(x)\n  } else {\n    # For low order calculation, use \n    N1plus_pre(x)\n  } \n}\n\n\n\n####################################\n\nalpha <- function(x,high_order) {\n  # Lambda function for Kneser_ney\n  # Parameters:\n  #   lambda(x) = (D / N1+_prec(x)) * N1+_suc(x)\n  #   x:  n-gram to be considered, with the following format\n  #       c(\"t1\") # unigram\n  #       c(\"t1\",t2\") # bigram\n  #   dt: data table that have the frequency for each ngram\n  #     c(\"t1\",\"t2\",\"freq\",\"prob\") # bigram\n  #     c(\"t1\",\"t2\",\"t3\",\"freq\",\"prob\") # trigram\n  l <- length(x)\n  r <- -1\n  if (l == 2) {\n    # For bigrams use D2 for calculation\n    \n    if (high_order) {\n      r <- DT.bi[t1 == x[1] & t2 == x[2],a1,]\n    } else {\n      r <- DT.bi[t1 == x[1] & t2 == x[2],a2,]\n    }\n    \n    \n    if (r<0)\n    {\n      #r <- (D2 / count_kn(x,high_order)) * N1plus_suc(x)\n      r <- max( count_kn(x,high_order) - D2, 0) / count_kn(x[1],high_order)\n      \n      if (high_order) {\n        DT.bi[t1 == x[1] & t2 == x[2],a1:=r,]\n      } else {\n        DT.bi[t1 == x[1] & t2 == x[2],a2:=r,]\n      }\n    }\n    \n    \n  } else if (l == 3) {\n    # For trigrams use D3 for calculation \n    \n    if (high_order) {\n      r <- DT.tri[t1 == x[1] & t2 == x[2] & t3 ==x[3],a1,]\n    } else {\n      r <- DT.tri[t1 == x[1] & t2 == x[2] & t3 ==x[3],a2,]\n    }\n    \n    if (r<0) {\n      #r <- (D3 / count_kn(x,high_order)) * N1plus_suc(x)\n      r <- max( count_kn(x,high_order) - D3, 0) / count_kn(c(x[1],x[2]),high_order)\n      \n      \n      if (high_order) {\n        DT.tri[t1 == x[1] & t2 == x[2] & t3 ==x[3],a1:=r,]\n      } else {\n        DT.tri[t1 == x[1] & t2 == x[2] & t3 ==x[3],a2:=r,]\n      }\n    }\n    \n    \n  } else if (l == 4) {\n    # For quadgrams use D4 for calculation \n    \n    if (high_order) {\n      r <- DT.quad[t1 == x[1] & t2 == x[2] & t3 ==x[3] & t4 ==x[4],a1,]\n    } else {\n      r <- DT.quad[t1 == x[1] & t2 == x[2] & t3 ==x[3] & t4 ==x[4],a2,]\n    }\n    \n    if (r<0) {\n      #r <- (D4 / count_kn(x,high_order)) * N1plus_suc(x)\n      r <- max( count_kn(x,high_order) - D4, 0) / count_kn(c(x[1],x[2],x[3]),high_order)\n      \n      #max( N1plus_pre(x) - D4, 0) / N1plus_pre(c(x[1],x[2],x[3]))\n      \n      if (high_order) {\n        DT.quad[t1 == x[1] & t2 == x[2] & t3 ==x[3] & t4 ==x[4],a1:=r,]\n      } else {\n        DT.quad[t1 == x[1] & t2 == x[2] & t3 ==x[3] & t4 ==x[4],a2:=r,]\n      }    \n    }\n  }\n  r\n}\n\n\n####################################\n\nlambda <- function(x,high_order) {\n  # Lambda function for Kneser_ney\n  # Parameters:\n  #   lambda(x) = (D / N1+_prec(x)) * N1+_suc(x)\n  #   x:  n-gram to be considered, with the following format\n  #       c(\"t1\") # unigram\n  #       c(\"t1\",t2\") # bigram\n  #   dt: data table that have the frequency for each ngram\n  #     c(\"t1\",\"t2\",\"freq\",\"prob\") # bigram\n  #     c(\"t1\",\"t2\",\"t3\",\"freq\",\"prob\") # trigram\n  l <- length(x)\n  r <- -1\n  if (l == 1) {\n    # For unigrams use D2 for calculation\n    \n    if (high_order) {\n      r <- DT.uni[t1 == x[1],l1,]\n    } else {\n      r <- DT.uni[t1 == x[1],l2,]\n    }\n    \n    if (r<0)\n    {\n      r <- (D2 / count_kn(x,high_order)) * N1plus_suc(x)\n      if (high_order) {\n        DT.uni[t1 == x[1],l1:=r,]\n      } else {\n        DT.uni[t1 == x[1],l2:=r,]\n      }\n    }\n    \n    \n  } else if (l == 2) {\n    # For bigrams use D3 for calculation \n    \n    if (high_order) {\n      r <- DT.bi[t1 == x[1] & t2 == x[2],l1,]\n    } else {\n      r <- DT.bi[t1 == x[1] & t2 == x[2],l2,]\n    }\n    \n    if (r<0) {\n      r <- (D3 / count_kn(x,high_order)) * N1plus_suc(x)\n      if (high_order) {\n        DT.bi[t1 == x[1] & t2 == x[2],l1:=r,]\n      } else {\n        DT.bi[t1 == x[1] & t2 == x[2],l2:=r,]\n      }\n    }\n    \n    \n  } else if (l == 3) {\n    # For trigrams use D4 for calculation \n    \n    if (high_order) {\n      r <- DT.tri[t1 == x[1] & t2 == x[2] & t3 ==x[3],l1,]\n    } else {\n      r <- DT.tri[t1 == x[1] & t2 == x[2] & t3 ==x[3],l2,]\n    }\n    \n    if (r<0) {\n      r <- (D4 / count_kn(x,high_order)) * N1plus_suc(x)\n      if (high_order) {\n        DT.tri[t1 == x[1] & t2 == x[2] & t3 ==x[3],l1:=r,]\n      } else {\n        DT.tri[t1 == x[1] & t2 == x[2] & t3 ==x[3],l2:=r,]\n      }    \n    }\n  }\n  r\n}\n\n\n#########################################\n\nprob_cont_kn <- function(x) {\n  # For recursion purposes, when we call this function we are in low order\n  l <- length(x)\n  r <- -1\n  \n  if (l ==1) { \n    #unigram level\n    r <- DT.uni[t1 == x[1],pkn1,]\n    \n    if (r < 0) {\n      r <- N1plus_pre(x) / n.bi\n      DT.uni[t1 == x[1],pkn1:=r,]\n    }\n  }\n  else if (l==2) { \n    #bigram level\n    \n    r <- DT.bi[t1 == x[1] & t2 == x[2],pkn2,]\n    if (r < 0) {\n      r <- alpha(x,FALSE) + lambda(x[1],FALSE) * prob_cont_kn(x[2])\n      DT.bi[t1 == x[1] & t2 == x[2],pkn2:=r,]\n    }\n    \n  } else if (l==3) {\n    #trigram level\n    r <- DT.tri[t1 == x[1] & t2 == x[2] & t3 == x[3],pkn2,]\n    if (r < 0) {\n      r <- alpha(x,FALSE) + lambda(c(x[1],x[2]),FALSE) * prob_cont_kn(c(x[2],x[3]))\n      DT.tri[t1 == x[1] & t2 == x[2] & t3 == x[3],pkn2:=r,]\n    }\n  } else if (l==4) {\n    #quadgram level\n    \n    r <- DT.quad[t1 == x[1] & t2 == x[2] & t3 == x[3] & t4 == x[4],pkn2,]\n    if (r < 0) {\n      r <- alpha(x,FALSE) + lambda(c(x[1],x[2],x[3]),FALSE) * prob_cont_kn(c(x[2],x[3],x[4]))\n      DT.quad[t1 == x[1] & t2 == x[2] & t3 == x[3] & t4 == x[4],pkn2:=r,]\n    }\n  }\n  r\n}\n\nprob_kneser_ney <- function(x) {\n  \n  l <- length(x)\n  r <- -1\n  \n  if (l == 1) {\n    #uni-gram level\n    r <- DT.uni[t1 == x[1],pkn1,]\n    \n    if (r < 0) {\n      r <- N1plus_pre(x) / n.bi\n      DT.uni[t1 == x[1],pkn1:=r,]\n    }\n  }\n  else if (l == 2) {\n    #bigram level\n    r <- DT.bi[t1 == x[1] & t2 == x[2],pkn1,]\n    if (r < 0) {\n      r <- alpha(x,TRUE) + lambda(x[1],TRUE) * prob_cont_kn(x[2])\n      DT.bi[t1 == x[1] & t2 == x[2],pkn1:=r,]\n    }\n  }\n  else if (l == 3) {\n    #trigram level\n    r <- DT.tri[t1 == x[1] & t2 == x[2] & t3 == x[3],pkn1,]\n    if (r < 0) {\n      r <- alpha(x,TRUE) + lambda(c(x[1],x[2]),TRUE) * prob_cont_kn(c(x[2],x[3]))\n      DT.tri[t1 == x[1] & t2 == x[2] & t3 == x[3],pkn1:=r,]\n    }\n  }\n  else if (l == 4) {\n    #quadgram level\n    r <- DT.quad[t1 == x[1] & t2 == x[2] & t3 == x[3] & t4 == x[4],pkn1,]\n    if (r < 0) {\n      r <- alpha(x,TRUE) + lambda(c(x[1],x[2],x[3]),TRUE) * prob_cont_kn(c(x[2],x[3],x[4]))\n      DT.quad[t1 == x[1] & t2 == x[2] & t3 == x[3] & t4 == x[4],pkn1:=r,]\n    }\n  }\n}\n\n\nsave_dt_prob_temp <- function(n,lines=-1) {\n  if (n >= 1) {\n    file.name <- create_filename(\"DT_uni_prob_temp\",lines)\n    print(paste(\"... Saving DT probability temp file:\",file.name,sep=\"\"))\n    save(DT.uni,file=file.name)\n  } \n  if (n >= 2) {\n    file.name <- create_filename(\"DT_bi_prob_temp\",lines)\n    print(paste(\"... Saving DT probability temp file:\",file.name,sep=\"\"))\n    save(DT.bi,file=file.name)\n  }\n  if (n >= 3) {\n    file.name <- create_filename(\"DT_tri_prob_temp\",lines)\n    print(paste(\"... Saving DT probability temp file:\",file.name,sep=\"\"))\n    save(DT.tri,file=file.name)\n  } \n  if (n == 4) {\n    file.name <- create_filename(\"DT_quad_prob_temp\",lines)\n    print(paste(\"... Saving DT probability temp file:\",file.name,sep=\"\"))\n    save(DT.quad,file=file.name)\n  }\n}\n  \n\ncalculate_prob_kn_range <- function(n,lines=-1,init,final)  \n{\n  \n  if (n == 1) {\n    file.name <- create_filename(\"DT_uni_prob\",lines)\n  } else if (n == 2) {\n    file.name <- create_filename(\"DT_bi_prob\",lines)\n  } else if (n == 3) {\n    file.name <- create_filename(\"DT_tri_prob\",lines)\n  } else if (n == 4) {\n    file.name <- create_filename(\"DT_quad_prob\",lines)\n  }\n  \n  print(paste(\"-----> calculate_prob_kn_range(\",n,\",\",lines,\",\",init,\",\",final,\").......\",sep=\"\"))\n  tic1 <- proc.time()\n\n  if (n==1) {\n    \n    for (i in init:final) {\n      t1 <- as.character(DT.bi[i,t1,])\n      t2 <- as.character(DT.bi[i,t2,])\n      prob_kneser_ney(c(t1,t2))\n    }\n    # Saving DT prob temp files\n    save_dt_prob_temp(n,lines)\n    \n  }\n  tic2 <- proc.time()\n  print(paste(\"-----> calculate_prob_kn_range: Running Time .......\",\n              elapsed_time(tic1,tic2),\" seconds ...\",sep=\"\"))\n}\n\n\n  \n\n\n  \ncalculate_prob_kn <- function(n,lines=-1,numlines=-1) {\n    \n  if (n == 1) {\n    var.name <- \"DT.uni.prob\"\n    file.name <- create_filename(\"DT_uni_prob\",lines)\n    file.name.final <- create_filename(\"DT_uni_prob_final\",lines)\n  } else if (n == 2) {\n    var.name <- \"DT.bi.prob\"\n    file.name <- create_filename(\"DT_bi_prob\",lines)\n    file.name.final <- create_filename(\"DT_bi_prob_final\",lines)\n  } else if (n == 3) {\n    var.name <- \"DT.tri.prob\"\n    file.name <- create_filename(\"DT_tri_prob\",lines)\n    file.name.final <- create_filename(\"DT_tri_prob_final\",lines)\n  } else if (n == 4) {\n    var.name <- \"DT.quad.prob\"\n    file.name <- create_filename(\"DT_quad_prob\",lines)\n    file.name.final <- create_filename(\"DT_quad_prob_final\",lines)\n  }\n  \n  #Validate if the DT with the probability exists in the enviroment\n  if (!exists(var.name)) {\n    #Validate if the file exists an load the value\n    if (file.exists(file.name)) {\n      print(paste(\"Loading DT with probability file: \",file.name, sep =\"\"))\n      load(file.name,.GlobalEnv) \n    } else {\n      \n      print(paste(\"-----> calculate_prob_kn(\",n,\",\",lines,\",\",numlines,\").......\",sep=\"\"))\n      tic1 <- proc.time()\n      \n      print(paste(\"... Creating DT with prob:\", var.name, sep=\"\"))\n      \n      if (n == 1) {\n        ## For each unigram lets calculate the kneser-ney prob\n        if (numlines == -1) { numlines <- nrow(DT.uni) }\n        \n        percent_1 <- round(numlines/100)\n        print(paste(\"... Calculating Knersey-ney prob for:\",numlines,\" 1% is:\",percent_1))\n        k <- 1\n        m <- 1\n        \n        nic1 <- proc.time()\n        \n        for (i in 1:numlines) \n        {\n          t1 <- as.character(DT.uni[i,t1,])\n          prob_kneser_ney(c(t1))\n          \n          ### To give some feedback, print a message each 10%\n          if (k==percent_1) {\n            nic2 <- proc.time()\n            print(paste(\"......\",m,\"% done in \",\n                        elapsed_time(nic1,nic2),\" seconds ...\",sep=\"\"))\n            \n            k <- 1\n            m <- m + 1\n          } else { k <- k + 1}\n          #print(paste(\" i:\",i,\" total:\",numlines,\" percent10:\",percent_1,\" k:\",k,\" m:\",m))\n            \n        }\n        #print(paste(\"... Saving DT probability file:\",file.name,sep=\"\"))\n        #save(DT.uni,file=file.name)\n        \n        # Saving DT prob temp files\n        save_dt_prob_temp(n,lines)\n        \n        # Clean the DT with only two columns (t1,prob)\n        DT.uni.prob <<- DT.uni[,list(t1,pkn1),]\n        DT.uni.prob[,prob:=pkn1,]\n        DT.uni.prob <<- DT.uni.prob[,list(t1,prob),]\n        \n        print(paste(\"... Saving DT probability final file:\",file.name.final,sep=\"\"))\n        save(DT.uni.prob,file=file.name.final)\n        \n        #rm(\"DT.uni\",envir =.GlobalEnv)\n      } else if (n == 2) {\n        ## For each bigram lets calculate the kneser-ney prob\n        \n        if (numlines == -1) { numlines <- nrow(DT.bi)}\n        \n        \n        percent_1 <- round(numlines/100)\n        \n        print(paste(\"... Calculating Knersey-ney prob for:\",numlines,\" 1% is:\",percent_1))\n        \n        \n        k <- 1\n        m <- 1\n        \n        nic1 <- proc.time()\n        \n        for (i in 1:numlines) {\n          t1 <- as.character(DT.bi[i,t1,])\n          t2 <- as.character(DT.bi[i,t2,])\n          prob_kneser_ney(c(t1,t2))\n          \n          ### To give some feedback, print a message each 10%\n          if (k==percent_1) {\n            nic2 <- proc.time()\n            print(paste(\"......\",m,\"% done in \",\n                        elapsed_time(nic1,nic2),\" seconds ...\",sep=\"\"))\n            \n            k <- 1\n            m <- m + 1\n          } else { k <- k + 1}\n          #print(paste(\" i:\",i,\" total:\",numlines,\" percent10:\",percent_1,\" k:\",k,\" m:\",m))\n          \n        }\n        #print(paste(\"... Saving DT probability file:\",file.name,sep=\"\"))\n        #save(DT.bi,file=file.name)\n        \n        # Saving DT prob temp files\n        save_dt_prob_temp(n,lines)\n        \n        # Clean the DT with only two columns (t1,t2,prob)\n        DT.bi.prob <<- DT.bi[,list(t1,t2,pkn1),]\n        DT.bi.prob[,prob:=pkn1,]\n        DT.bi.prob <<- DT.bi.prob[,list(t1,t2,prob),]\n        \n        print(paste(\"... Saving DT probability final file:\",file.name.final,sep=\"\"))\n        save(DT.bi.prob,file=file.name.final)\n        #rm(\"DT.bi\",envir =.GlobalEnv)\n\n      } else if (n == 3) {\n        ## For each trigram lets calculate the kneser-ney prob\n        \n\n        if (numlines == -1) { numlines <- nrow(DT.tri) }\n        \n        percent_1 <- round(numlines/100)\n        print(paste(\"... Calculating Knersey-ney prob for:\",numlines,\" 1% is:\",percent_1))\n        k <- 1\n        m <- 1\n        \n        nic1 <- proc.time()\n        \n        for (i in 1:numlines) {\n          t1 <- as.character(DT.tri[i,t1,])\n          t2 <- as.character(DT.tri[i,t2,])\n          t3 <- as.character(DT.tri[i,t3,])\n          prob_kneser_ney(c(t1,t2,t3))\n          \n          ### To give some feedback, print a message each 10%\n          if (k==percent_1) {\n            nic2 <- proc.time()\n            print(paste(\"......\",m,\"% done in \",\n                        elapsed_time(nic1,nic2),\" seconds ...\",sep=\"\"))\n\n            k <- 1\n            m <- m + 1\n          } else { k <- k + 1}\n          #print(paste(\" i:\",i,\" total:\",numlines,\" percent10:\",percent_1,\" k:\",k,\" m:\",m))\n        }\n        #print(paste(\"... Saving DT probability file:\",file.name,sep=\"\"))\n        #save(DT.tri,file=file.name)\n        \n        # Saving DT prob temp files\n        save_dt_prob_temp(n,lines)\n        \n        # Clean the DT with only four columns (t1,t2,t3,prob)\n        DT.tri.prob <<- DT.tri[,list(t1,t2,t3,pkn1),]\n        DT.tri.prob[,prob:=pkn1,]\n        DT.tri.prob <<- DT.tri.prob[,list(t1,t2,t3,prob),]\n        \n        print(paste(\"... Saving DT probability final file:\",file.name.final,sep=\"\"))\n        save(DT.tri.prob,file=file.name.final)\n        \n        #rm(\"DT.tri\",envir =.GlobalEnv)\n        \n      } else if (n == 4) {\n        ## For each quadgram lets calculate the kneser-ney prob\n        \n        if (numlines == -1) { numlines <- nrow(DT.quad) }\n        \n        percent_1 <- round(numlines/100)\n        print(paste(\"... Calculating Knersey-ney prob for:\",numlines,\" 1% is:\",percent_1))\n        k <- 1\n        m <- 10\n        \n        nic1 <- proc.time()\n        \n        for (i in 1:numlines) {\n          t1 <- as.character(DT.quad[i,t1,])\n          t2 <- as.character(DT.quad[i,t2,])\n          t3 <- as.character(DT.quad[i,t3,])\n          t4 <- as.character(DT.quad[i,t4,])\n          prob_kneser_ney(c(t1,t2,t3,t4))\n          \n          ### To give some feedback, print a message each 10%\n          if (k==percent_1) {\n            nic2 <- proc.time()\n            \n            print(paste(\"......\",m,\"% done in \",\n                        elapsed_time(nic1,nic2),\" seconds ...\",sep=\"\"))\n            \n            k <- 1\n            m <- m + 1\n          } else { k <- k + 1}\n          #print(paste(\" i:\",i,\" total:\",numlines,\" percent1:\",percent_1,\" k:\",k,\" m:\",m))\n        }\n        #print(paste(\"... Saving DT probability file:\",file.name,sep=\"\"))\n        #save(DT.quad,file=file.name)\n        \n        # Saving DT prob temp files\n        save_dt_prob_temp(n,lines)\n        \n        # Clean the DT with only five columns (t1,t2,t3,t4,prob)\n        DT.quad.prob <<- DT.quad[,list(t1,t2,t3,t4,pkn1),]\n        DT.quad.prob[,prob:=pkn1,]\n        DT.quad.prob <<- DT.quad.prob[,list(t1,t2,t3,t4,prob),]\n        \n        print(paste(\"... Saving DT probability final file:\",file.name.final,sep=\"\"))\n        save(DT.quad.prob,file=file.name.final)\n        #rm(\"DT.quad\",envir =.GlobalEnv)\n      }\n      tic2 <- proc.time()\n      print(paste(\"-----> calculate_prob_kn: Running Time .......\",\n                  elapsed_time(tic1,tic2),\" seconds ...\",sep=\"\"))\n    }\n  }\n}",
    "created" : 1467291401146.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "849021351",
    "id" : "76D661D0",
    "lastKnownWriteTime" : 1467291933,
    "last_content_update" : 1467291933411,
    "path" : "D:/Coursera/Capstone Project/Coursera---Data-Science---Capstone-Project/Knersey-ney vFinal.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}