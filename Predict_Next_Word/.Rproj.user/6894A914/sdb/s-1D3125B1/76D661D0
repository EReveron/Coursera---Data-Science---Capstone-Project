{
    "collab_server" : "",
    "contents" : "#####################################################################\n# Knersey-ney VFinal\n# Calculate Knersey-ney of the differents ngrams (unigram, bigram, trigram and quadgrams)\n#          to be used later with Kneser-ney algortihm to calculate the\n#          probability of each ngram for predict the next word.\n#          This script was run on my PC and takes long time to finish,\n#          at the end this script saves the data into four files:\n#\n#             uni_dt.Rdata: data frame that include all the unigrams and the\n#                          frequency for each one.\n#             bi_dt.Rdata: data frame that include all the bigrams and the\n#                          frequency for each one.\n#             tri_dt.Rdata: data frame that include all the trigrams and the\n#                          frequency for each one.\n#             quad_dt.Rdata: data frame that include all the quadgrams and the\n#                          frequency for each one.\n# In this version we did some optimizations related with the recursion.\n# We start calculating the unigrams probability. This calculation could be used\n# on bigrams, trigrams and quadgrams calculations. To do that we also store some \n# values as N1plus_pre(x), N1plus_suc(x), alpha(x), lambda(x). \n\nlibrary(data.table)\n\n#setwd(\"D:/Coursera/Capstone Project/Coursera-SwiftKey/final/en_US\")\n#setwd(\"D:/001 -- Coursera/Capstone Project/Coursera-SwiftKey/final/en_US\")\n\n# For reproducibility\nset.seed(12345)\n\n####################################\nelapsed_time <- function(tic1,tic2) {\n  format((tic2-tic1)[3][[1]], digits = 2)\n}\n\n####################################\ncreate_filename <- function(x,lines) {\n  \n  if (lines < 0) {\n    paste(x,\"_all.RData\",sep= \"\")\n  }\n  else {\n    paste(x,\"_\",lines,\".RData\",sep= \"\")\n  }\n}\n\n\n\n####################################\nN1plus_pre <- function(x) {\n  # Count the number of unique words that precede the ngram x \n  # with at least 1 appareance (freq). This value will be stored\n  # in the corresponding ngram table in the column with the name \"n11\"\n\n  l <- as.character(length(x))\n  r <- -1\n  \n  switch(l,\n         \"1L\" = { #Unigrams\n           #Check if the value exists in the ngram table\n           r <- DT.uni.prob[t1 == x[1],n11,]\n           \n           if (r < 0) {\n             # Calculate the value and store it in the table\n             r <- nrow(DT.bi.prob[t2 == x[1] & freq >= 1,,])\n             DT.uni.prob[t1 == x[1],n11:=r,]\n           }\n         },\n         \"2L\" = { #Bigrams\n           #Check if the value exists in the ngram table\n           r <- DT.bi.prob[t1 == x[1] & t2 == x[2],n11,]\n           \n           if (r < 0) {\n             # Calculate the value and store it in the table\n             r <- nrow(DT.tri.prob[t2 == x[1] & t3 == x[2] & freq >= 1,,])\n             DT.bi.prob[t1 == x[1] & t2 == x[2],n11:=r,]\n           }\n         },\n         \"3L\" = { #Trigrams\n           #Check if the value exists in the ngram table\n           r <- DT.tri.prob[t1 == x[1] & t2 == x[2] & t3 == x[3],n11,]\n           \n           if (r < 0) {\n             # Calculate the value and store it in the table\n             r <- nrow(DT.quad.prob[t2 == x[1] & t3 == x[2] & t4 == x[3] & freq >= 1,,])\n             DT.tri.prob[t1 == x[1] & t2 == x[2] & t3 == x[3],n11:=r,]\n           }\n         }\n  )\n  r\n}\n\n####################################\nN1plus_suc <- function(x) {\n  # Count the number of unique words that succeed the ngram x \n  # with at least 1 appareance (freq). This value will be stored\n  # in the corresponding ngram table in the column with the name \"n12\"\n  \n  l <- as.character(length(x))\n  r <- -1\n  \n  switch(l,\n         \"1L\" = { #Unigram\n           #Check if the value exists in the ngram table\n           r <- DT.uni.prob[t1 == x[1],n12,]\n           \n           if (r < 0)\n           {\n             # Calculate the value and store it in the table\n             r <- nrow(DT.bi.prob[t1 == x[1] & freq >= 1,,])\n             DT.uni.prob[t1 == x[1],n12:=r,]\n           }\n         },\n         \"2L\" = { \n           #Check if the value exists in the ngram table\n           r <- DT.bi.prob[t1 == x[1] & t2 == x[2],n12,]\n           \n           if (r<0)\n           {\n             # Calculate the value and store it in the table\n             r <- nrow(DT.tri.prob[t1 == x[1] & t2 == x[2] & freq >= 1,,])\n             DT.bi.prob[t1 == x[1] & t2 == x[2],n12:=r,]\n           }\n         },\n         \"3L\" = {\n           #Check if the value exists in the ngram table\n           r <-  DT.tri.prob[t1 == x[1] & t2 == x[2] & t3 == x[3], n12,]\n           \n           if (r < 0) {\n             # Calculate the value and store it in the table\n             r <- nrow(DT.quad.prob[t1 == x[1] & t2 == x[2] & t3 == x[3] & freq >= 1,,])\n             DT.tri.prob[t1 == x[1] & t2 == x[2] & t3 == x[3], n12:=r,]\n           }\n         }\n  )\n  r\n}\n         \n         \n         \n    \n####################################\nngram_count <- function(x) {\n  # Count the number of times that the ngram x appears on the corresponding table\n\n  l <- as.character(length(x))\n  switch(l,\n         \"1L\" = DT.uni.prob[t1 == x[1],freq,],\n         \"2L\" = DT.bi.prob[t1 == x[1] & t2 == x[2],freq,],\n         \"3L\" = DT.tri.prob[t1 == x[1] & t2 == x[2] & t3 == x[3],freq,],\n         \"4L\" = DT.quad.prob[t1 == x[1] & t2 == x[2] & t3 == x[3] & t4 == x[4],freq,]\n  )\n}     \n         \n         \n  \n\n####################################\ncount_kn <- function(x,high_order) {\n  # Count function for knersey-ney calculation. \n  \n  if (high_order) {\n    # For high order calculations, use ngram_count(x)\n    ngram_count(x)\n  } else {\n    # For low order calculation, use \n    N1plus_pre(x)\n  } \n}\n\n\n\n####################################\nalpha <- function(x,high_order) {\n  # Alpha function for Kneser-ney:\n  # alpha(x) = max( count_kn(x) - D2, 0) / count_kn(x[1],high_order)\n  # This value will be stored in the corresponding ngram table in the column \n  # with the name \"a1\"/\"a2\" (high/low order)\n  \n  l <- as.character(length(x))\n  r <- -1\n  \n  #print(paste(\"L vale:\",l))\n  \n  \n  switch(l,\n         \"2L\" = { # bigrams, check the table for a1 or a2 values (high/low order)\n           \n           print(\"bigrams\")\n           if (high_order) {\n             r <- DT.bi.prob[t1 == x[1] & t2 == x[2],a1,]\n           } else {\n             r <- DT.bi.prob[t1 == x[1] & t2 == x[2],a2,]\n           }\n           \n           print(paste(\"R vale:\",r))\n           \n           if (r < 0) {\n             # Calculate the value and store it in the table\n             r <- max( count_kn(x,high_order) - D2, 0) / count_kn(x[1],high_order)\n             \n             if (high_order) {\n               DT.bi.prob[t1 == x[1] & t2 == x[2],a1:=r,]\n             } else {\n               DT.bi.prob[t1 == x[1] & t2 == x[2],a2:=r,]\n             }\n           }\n         },\n         \n         \"3L\" = { # trigrams, check the table for a1 or a2 values (high/low order)\n           print(\"trigrams\")\n           if (high_order) {\n             r <- DT.tri.prob[t1 == x[1] & t2 == x[2] & t3 ==x[3],a1,]\n           } else {\n             r <- DT.tri.prob[t1 == x[1] & t2 == x[2] & t3 ==x[3],a2,]\n           }\n           \n           if (r < 0) {\n             # Calculate the value and store it in the table\n             r <- max( count_kn(x,high_order) - D3, 0) / count_kn(c(x[1],x[2]),high_order)\n             \n             if (high_order) {\n               DT.tri.prob[t1 == x[1] & t2 == x[2] & t3 ==x[3],a1:=r,]\n             } else {\n               DT.tri.prob[t1 == x[1] & t2 == x[2] & t3 ==x[3],a2:=r,]\n             }\n           }\n         },\n         \"4L\" = { # quadgrams, check the table for a1 or a2 values (high/low order)  \n           print(\"quadgrams\")\n           if (high_order) {\n             r <- DT.quad.prob[t1 == x[1] & t2 == x[2] & t3 ==x[3] & t4 ==x[4],a1,]\n           } else {\n             r <- DT.quad.prob[t1 == x[1] & t2 == x[2] & t3 ==x[3] & t4 ==x[4],a2,]\n           }\n           \n           if (r < 0) {\n             # Calculate the value and store it in the table\n             r <- max( count_kn(x,high_order) - D4, 0) / count_kn(c(x[1],x[2],x[3]),high_order)\n             \n             if (high_order) {\n               DT.quad.prob[t1 == x[1] & t2 == x[2] & t3 ==x[3] & t4 ==x[4],a1:=r,]\n             } else {\n               DT.quad.prob[t1 == x[1] & t2 == x[2] & t3 ==x[3] & t4 ==x[4],a2:=r,]\n             }    \n           }\n         }\n  )\n  r\n}          \n      \n  \n \n\n####################################\nlambda <- function(x,high_order=TRUE) {\n  \n  # Lambba function for Kneser-ney:\n  #     lambda(x) = (D / count_kn(x) * N1+_suc(x)\n  # This value will be stored in the corresponding ngram table in the column \n  # with the name \"l1\"/\"l2\" (high/low order)\n  \n  l <- as.character(length(x))\n  r <- -1\n  \n  switch(l,\n         \"1L\" = { # Unigrams, check the table for l1 or l2 values (high/low order)\n           if (high_order) {\n             r <- DT.uni.prob[t1 == x[1],l1,]\n           } else {\n             r <- DT.uni.prob[t1 == x[1],l2,]\n           }\n           \n           if (r < 0) {\n             # Calculate the value and store it in the table\n             r <- (D2 / count_kn(x,high_order)) * N1plus_suc(x)\n             if (high_order) {\n               DT.uni.prob[t1 == x[1],l1:=r,]\n             } else {\n               DT.uni.prob[t1 == x[1],l2:=r,]\n             }\n           }\n         },\n         \n         \"2L\" = { # Bigrams, check the table for l1 or l2 values (high/low order)\n           if (high_order) {\n             r <- DT.bi.prob[t1 == x[1] & t2 == x[2],l1,]\n           } else {\n             r <- DT.bi.prob[t1 == x[1] & t2 == x[2],l2,]\n           }\n           \n           if (r < 0) {\n             # Calculate the value and store it in the table\n             r <- (D3 / count_kn(x,high_order)) * N1plus_suc(x)\n             if (high_order) {\n               DT.bi.prob[t1 == x[1] & t2 == x[2],l1:=r,]\n             } else {\n               DT.bi.prob[t1 == x[1] & t2 == x[2],l2:=r,]\n             }\n           }\n         },\n         \"3L\" = { # Trigrams, check the table for l1 or l2 values (high/low order)\n           if (high_order) {\n             r <- DT.tri.prob[t1 == x[1] & t2 == x[2] & t3 ==x[3],l1,]\n           } else {\n             r <- DT.tri.prob[t1 == x[1] & t2 == x[2] & t3 ==x[3],l2,]\n           }\n           \n           if (r < 0) {\n             r <- (D4 / count_kn(x,high_order)) * N1plus_suc(x)\n             if (high_order) {\n               DT.tri.prob[t1 == x[1] & t2 == x[2] & t3 ==x[3],l1:=r,]\n             } else {\n               DT.tri.prob[t1 == x[1] & t2 == x[2] & t3 ==x[3],l2:=r,]\n             }    \n           }\n         }\n  )\n  r\n}\n         \n         \n         \n         \n         \n\n\n####################################\nprob_kneser_ney <- function(x,high_order = TRUE) {\n  \n  l <- as.character(length(x))\n  r <- -1\n  \n  switch(l,\n         \n         \"1L\" = { # Unigrams, check the table for pkn1 values (high/low order)\n           r <- DT.uni.prob[t1 == x[1],pkn1,]\n           \n           if (r < 0) {\n             # Calculate the value and store it in the table\n             r <- N1plus_pre(x) / n.bi\n             DT.uni.prob[t1 == x[1],pkn1:=r,]\n           }\n         },\n         \n         \"2L\" = { # Bigrams, check the table for pkn1 or pkn2 values (high/low order)\n           if (high_order) {\n             r <- DT.bi.prob[t1 == x[1] & t2 == x[2],pkn1,]\n           } else {\n             r <- DT.bi.prob[t1 == x[1] & t2 == x[2],pkn2,]\n           }\n           \n           if (r < 0) {\n             # Calculate the value and store it in the table\n             r <- alpha(x,high_order) + \n               lambda(x[1],high_order) * prob_kneser_ney(x[2], FALSE)\n             \n             if (high_order) {\n               DT.bi.prob[t1 == x[1] & t2 == x[2],pkn1:=r,]\n             } else {\n               DT.bi.prob[t1 == x[1] & t2 == x[2],pkn2:=r,]\n             }\n           } \n         },\n         \n         \"3L\" = { # Trigrams, check the table for pkn1 or pkn2 values (high/low order)\n           if (high_order) {\n             r <- DT.tri.prob[t1 == x[1] & t2 == x[2] & t3 == x[3],pkn1,]\n           } else {\n             r <- DT.tri.prob[t1 == x[1] & t2 == x[2] & t3 == x[3],pkn2,]\n           }\n           if (r < 0) {\n             # Calculate the value and store it in the table\n             r <- alpha(x,high_order) + \n               lambda(c(x[1],x[2]),high_order) * prob_kneser_ney(c(x[2],x[3]),FALSE)\n             if (high_order) {\n               DT.tri.prob[t1 == x[1] & t2 == x[2] & t3 == x[3],pkn1:=r,]\n             } else {\n               DT.tri.prob[t1 == x[1] & t2 == x[2] & t3 == x[3],pkn2:=r,]\n             }\n           }\n         },\n         \n         \"4L\" = { # Quadgrams, check the table for pkn1 or pkn2 values (high/low order)\n           if (high_order) {\n             r <- DT.quad.prob[t1 == x[1] & t2 == x[2] & t3 == x[3] & t4 == x[4],pkn1,]\n           } else {\n             r <- DT.quad.prob[t1 == x[1] & t2 == x[2] & t3 == x[3] & t4 == x[4],pkn2,]\n           }\n           if (r < 0) {\n             # Calculate the value and store it in the table\n             r <- alpha(x,high_order) + \n               lambda(c(x[1],x[2],x[3]),high_order) * prob_kneser_ney(c(x[2],x[3],x[4]),FALSE)\n             if (high_order) {\n               DT.quad.prob[t1 == x[1] & t2 == x[2] & t3 == x[3] & t4 == x[4],pkn1:=r,]\n             } else {\n               DT.quad.prob[t1 == x[1] & t2 == x[2] & t3 == x[3] & t4 == x[4],pkn2:=r,]\n             }\n           }\n         } \n  )\n  r\n}\n  \n\n####################################\nload_DT_table <- function (n,lines=-1L) {\n  \n  switch(n,\n         \"1\" = {\n           var.name <- \"DT.uni\"\n           file.name <- create_filename(\"DT_uni\",lines)\n         },\n         \"2\" = {\n           var.name <- \"DT.bi\"\n           file.name <- create_filename(\"DT_bi\",lines)\n         },\n         \"3\" = {\n           var.name <- \"DT.tri\"\n           file.name <- create_filename(\"DT_tri\",lines)\n         },\n         \"4\" = {\n           var.name <- \"DT.quad\"\n           file.name <- create_filename(\"DT_quad\",lines)\n         }\n  )\n  \n  #Validate if the DT exists in the enviroment\n  if (!exists(var.name)) {\n    #Validate if the file exists an load the value\n    if (file.exists(file.name)) {\n      print(paste(\"-----> load_DT_table(\",n,\").......\",sep=\"\"))\n      t1 <- proc.time()\n      \n      print(paste(\"Loading DT file: \",file.name, sep =\"\"))\n      load(file.name,.GlobalEnv) \n      \n      print(paste(\"Creating DT Table from:\",var.name, sep =\"\"))\n      \n      switch(n,\n             \"1\" = DT.uni <<- as.data.table(DT.uni, key = \"t1\"),\n             \"2\" = DT.bi <<- as.data.table(DT.bi, key = \"t1,t2\"),\n             \"3\" = DT.tri <<- as.data.table(DT.tri, key = \"t1,t2,t3\"),\n             \"4\" = DT.quad <<- as.data.table(DT.quad, key = \"t1,t2,t3,t4\")\n      )\n      \n      t2 <- proc.time()\n      print(paste(\"-----> load_DT_table: Running Time .......\",\n                  elapsed_time(t1,t2),\" seconds ...\",sep=\"\"))\n      \n    }\n    else {\n      # Error file doesn't exists\n      print(paste(\"Error file doesnt exist:\",file.name, sep=\"\"))\n    }\n  }\n}\n\n####################################\nload_DT_prob_table <- function (n,lines=-1L,p1=5L) {\n  \n  # Values needed for Knersey-ney prob calculations\n  p1 <<- p1\n  p2 <<- p1 + 1\n  \n  switch(n,\n         \"1\" = {\n           var.name <- \"DT.uni.prob\"\n           file.name.temp <- create_filename(\"DT_uni_prob_temp\",lines)\n         },\n         \"2\" = {\n           var.name <- \"DT.bi.prob\"\n           file.name.temp <- create_filename(\"DT_bi_prob_temp\",lines)\n         },\n         \"3\" = {\n           var.name <- \"DT.tri.prob\"\n           file.name.temp <- create_filename(\"DT_tri_prob_temp\",lines)\n         },\n         \"4\" = {\n           var.name <- \"DT.quad.prob\"\n           file.name.temp <- create_filename(\"DT_quad_prob_temp\",lines)\n         }\n  )\n  \n  #Validate if the DT prob temp exists in the enviroment\n  if (!exists(var.name)) {\n    #Validate if the file exists an load the value\n    if (file.exists(file.name.temp)) {\n      print(paste(\"Loading DT Prob temp file: \",file.name.temp, sep =\"\"))\n      load(file.name.temp,.GlobalEnv) \n    } else {\n      \n      \n      load_DT_table(n,lines)\n      print(paste(\"-----> load_DT_prob_table(\",\"n:=\",n,\" p1:=\",p1,\" lines:=\",lines,\").......\",sep=\"\"))\n      t1 <- proc.time()\n      \n      switch(n,\n             \"1\" = {\n               DT.uni.prob <<- as.data.table(DT.uni, key = \"t1\")\n               DT.uni.prob <<- DT.uni.prob[ freq >= p1,\n                                            c(\"n11\",\"n12\",\"l1\",\"l2\",\"a1\",\"a2\",\"pkn1\",\"pkn2\") :=\n                                              list(-1,-1,-1,-1,-1,-1,-1,-1),\n                                            ]\n               rm(DT.uni,envir =.GlobalEnv)\n             },\n             \"2\" = {\n               DT.bi.prob <<- as.data.table(DT.bi, key = \"t1,t2\")\n               DT.bi.prob <<- DT.bi.prob[ freq >= p1,\n                                c(\"n11\",\"n12\",\"l1\",\"l2\",\"a1\",\"a2\",\"pkn1\",\"pkn2\") :=\n                                  list(-1,-1,-1,-1,-1,-1,-1,-1),\n                                ]\n               rm(DT.bi,envir =.GlobalEnv)\n             },\n             \"3\" = {\n               DT.tri.prob <<- as.data.table(DT.tri, key = \"t1,t2,t3\")\n               DT.tri.prob <<- DT.tri.prob[ freq >= p1,\n                                            c(\"n11\",\"n12\",\"l1\",\"l2\",\"a1\",\"a2\",\"pkn1\",\"pkn2\") :=\n                                              list(-1,-1,-1,-1,-1,-1,-1,-1),\n                                            ]\n               rm(DT.tri,envir =.GlobalEnv)\n             },\n             \"4\" = {\n               DT.quad.prob <<- as.data.table(DT.quad, key = \"t1,t2,t3,t4\")\n               DT.quad.prob <<- DT.quad.prob[ freq >= p1,\n                                              c(\"n11\",\"n12\",\"l1\",\"l2\",\"a1\",\"a2\",\"pkn1\",\"pkn2\") :=\n                                                list(-1,-1,-1,-1,-1,-1,-1,-1),\n                                              ]\n               rm(DT.quad,envir =.GlobalEnv)\n             }\n      )\n      t2 <- proc.time()\n      print(paste(\"-----> load_DT_prob_table: Running Time .......\",\n                  elapsed_time(t1,t2),\" seconds ...\",sep=\"\"))\n    }\n    \n  }\n  \n  switch(n, # Calculate important values for Knersey-ney, including discount values \n         # (D2, D3, D4) for lambda function\n         \n         \"1\" = n.uni <<- nrow(DT.uni.prob),\n         \n         \"2\" = {\n           \n           #   n1: number of bigrams that occurs exactly p1 times\n           #   n2: number of bigrams that occurs exactly p1+1 times\n           #   D2 = n1 / (n1 + 2 * n2)\n           print(\"Creando D values\")\n           \n           n.bi <<- nrow(DT.bi.prob)\n           n1.bi <<- nrow(DT.bi.prob[freq == p1,,])\n           n2.bi <<- nrow(DT.bi.prob[freq == p2,,])\n           D2 <<- n1.bi / (n1.bi + 2 * n2.bi) \n         },\n         \n         \"3\" = {\n           #   n1: number of trigrams that occurs exactly p1 times\n           #   n2: number of trigrams that occurs exactly p1+1 times\n           #   D3 = n1 / (n1 + 2 * n2)\n           n.tri <<- nrow(DT.tri.prob)\n           n1.tri <<- nrow(DT.tri.prob[freq == p1,,])\n           n2.tri <<- nrow(DT.tri.prob[freq == p2,,])\n           D3 <<- n1.tri / (n1.tri + 2 * n2.tri) \n         },\n         \n         \"4\" = {\n           #   n1: number of quadgrams that occurs exactly p1 times\n           #   n2: number of quadgrams that occurs exactly p1+1 times\n           #   D4 = n1 / (n1 + 2 * n2)\n           n.quad <<- nrow(DT.quad.prob)\n           n1.quad <<- nrow(DT.quad.prob[freq == p1,,])\n           n2.quad <<- nrow(DT.quad.prob[freq == p2,,])\n           D4 <<- n1.quad / (n1.quad + 2 * n2.quad) \n         }\n         \n  )\n}    \n\n\n####################################\nload_DT_prob_tables <- function (n,lines=-1,p1=5) { \n  \n  print(paste(\"-----> load_DT_prob_tables(n:=\",n,\" p1:=\",p1,\" lines:=\",lines,\").......\",sep=\"\"))\n  t1 <- proc.time()\n  \n  if (n >= 1) {\n    load_DT_prob_table(1,lines,p1)\n    load_DT_prob_table(2,lines,p1)\n  } \n    \n  if (n >= 2) {\n      load_DT_prob_table(3,lines,p1)\n  }\n  \n  if (n >= 3) {\n    load_DT_prob_table(4,lines,p1)\n  } \n  t2 <- proc.time()\n  \n  print(paste(\"-----> load_DT_prob_tables: Running Time .......\",\n              elapsed_time(t1,t2),\" seconds ...\",sep=\"\"))\n}\n\n\n####################################\nsave_DT_prob_temp <- function(n,lines=-1) {\n  print(paste(\"-----> save_DT_prob_temp(n:=\",n,\" lines:=\",lines,\").......\",sep=\"\"))\n  t1 <- proc.time()\n  \n  if (n >= 1) {\n    file.name <- create_filename(\"DT_uni_prob_temp\",lines)\n    print(paste(\"... Saving DT probability temp file:\",file.name,sep=\"\"))\n    save(DT.uni.prob,file=file.name)\n  } \n  if (n >= 2) {\n    file.name <- create_filename(\"DT_bi_prob_temp\",lines)\n    print(paste(\"... Saving DT probability temp file:\",file.name,sep=\"\"))\n    save(DT.bi.prob,file=file.name)\n  }\n  if (n >= 3) {\n    file.name <- create_filename(\"DT_tri_prob_temp\",lines)\n    print(paste(\"... Saving DT probability temp file:\",file.name,sep=\"\"))\n    save(DT.tri.prob,file=file.name)\n  } \n  if (n == 4) {\n    file.name <- create_filename(\"DT_quad_prob_temp\",lines)\n    print(paste(\"... Saving DT probability temp file:\",file.name,sep=\"\"))\n    save(DT.quad.prob,file=file.name)\n  }\n  t2 <- proc.time()\n  \n  print(paste(\"-----> save_DT_prob_temp: Running Time .......\",\n              elapsed_time(t1,t2),\" seconds ...\",sep=\"\"))\n}\n  \n####################################  \ncalculate_prob_kn <- function(n,lines=-1,p1=5,numlines=-1) {\n    \n  switch(n,\n         \"1\" = {\n           var.name <- \"DT.uni.prob.final\"\n           file.name <- create_filename(\"DT_uni_prob_final\",lines)\n           file.name.final <- create_filename(\"DT_uni_prob_final\",lines)\n         },\n         \"2\" = {\n           var.name <- \"DT.bi.prob.final\"\n           file.name <- create_filename(\"DT_bi_prob_final\",lines)\n           file.name.final <- create_filename(\"DT_bi_prob_final\",lines)\n         },\n         \"3\" = {\n           var.name <- \"DT.tri.prob.final\"\n           file.name <- create_filename(\"DT_tri_prob_final\",lines)\n           file.name.final <- create_filename(\"DT_tri_prob_final\",lines)\n         },\n         \"4\" = {\n           var.name <- \"DT.quad.prob.final\"\n           file.name <- create_filename(\"DT_quad_prob_final\",lines)\n           file.name.final <- create_filename(\"DT_quad_prob_final\",lines)\n         }\n  )\n  \n  #Validate if the DT with the probability exists in the enviroment\n  if (!exists(var.name)) {\n    #Validate if the file exists an load the value\n    if (file.exists(file.name)) {\n      print(paste(\"Loading DT with probability file: \",file.name, sep =\"\"))\n      load(file.name,.GlobalEnv) \n    } else {\n      \n      load_DT_prob_tables(n,lines,p1)\n      \n      print(paste(\"-----> calculate_prob_kn(\",n,\",\",lines,\",\",numlines,\").......\",sep=\"\"))\n      tic1 <- proc.time()\n      \n      print(paste(\"Calculating DT Prob Table:\", var.name, sep=\"\"))\n      \n      \n      switch(n,\n             \"1\" = { # For each unigram lets calculate the kneser-ney prob\n               if (numlines == -1) { numlines <- nrow(DT.uni.prob) }\n               percent_1 <- round(numlines/100)\n               print(paste(\"Calculating Knersey-ney prob for:\",numlines,\" 1% is:\",percent_1))\n               k <- 1\n               m <- 1\n               nic1 <- proc.time()\n               \n               for (i in 1:numlines) \n               {\n                 t1 <- as.character(DT.uni.prob[i,t1,])\n                 prob_kneser_ney(c(t1))\n                 \n                 ### To give some feedback, print a message each 1%\n                 if (k==percent_1) {\n                   nic2 <- proc.time()\n                   print(paste(\"......\",m,\"% done in \",\n                               elapsed_time(nic1,nic2),\" seconds ...\",sep=\"\"))\n                   # Saving DT prob temp files\n                   save_DT_prob_temp(n,lines)\n                   k <- 1\n                   m <- m + 1\n                 } else { k <- k + 1}  \n                 #print(paste(\" i:\",i,\" total:\",numlines,\" percent10:\",percent_1,\" k:\",k,\" m:\",m))\n               }\n                 \n               # Clean the DT with only two columns (t1,prob)\n               DT.uni.prob.final <<- DT.uni.prob[,list(t1,pkn1),]\n               DT.uni.prob.final[,prob:=pkn1,]\n               DT.uni.prob.final <<- DT.uni.prob.final[,list(t1,prob),]\n               rm(DT.uni.prob,envir =.GlobalEnv)\n               \n               print(paste(\"Saving DT probability final file:\",file.name.final,sep=\"\"))\n               save(DT.uni.prob.final,file=file.name.final)\n             },\n             \n             \"2\" = {\n               ## For each bigram lets calculate the kneser-ney prob\n               if (numlines == -1) { numlines <- nrow(DT.bi.prob)}\n               percent_1 <- round(numlines/100)\n               print(paste(\"Calculating Knersey-ney prob for:\",numlines,\" 1% is:\",percent_1))\n               k <- 1\n               m <- 1\n               nic1 <- proc.time()\n               \n               for (i in 1:numlines) {\n                 t1 <- as.character(DT.bi.prob[i,t1,])\n                 t2 <- as.character(DT.bi.prob[i,t2,])\n                 prob_kneser_ney(c(t1,t2))\n                 \n                 ### To give some feedback, print a message each 1%\n                 if (k==percent_1) {\n                   nic2 <- proc.time()\n                   print(paste(\"......\",m,\"% done in \",\n                               elapsed_time(nic1,nic2),\" seconds ...\",sep=\"\"))\n                   # Saving DT prob temp files\n                   save_DT_prob_temp(n,lines)\n                   k <- 1\n                   m <- m + 1\n                 } else { k <- k + 1}\n                 #print(paste(\" i:\",i,\" total:\",numlines,\" percent10:\",percent_1,\" k:\",k,\" m:\",m))\n               }\n               \n               # Clean the DT with only two columns (t1,t2,prob)\n               DT.bi.prob.final <<- DT.bi.prob[,list(t1,t2,pkn1),]\n               DT.bi.prob.final[,prob:=pkn1,]\n               DT.bi.prob.final <<- DT.bi.prob.final[,list(t1,t2,prob),]\n               rm(DT.bi.prob,envir =.GlobalEnv)\n               \n               print(paste(\"Saving DT probability final file:\",file.name.final,sep=\"\"))\n               save(DT.bi.prob.final,file=file.name.final)\n             },\n             \n             \"3\" = {\n               ## For each trigram lets calculate the kneser-ney prob\n               if (numlines == -1) { numlines <- nrow(DT.tri.prob) }\n               \n               percent_1 <- round(numlines/100)\n               print(paste(\"Calculating Knersey-ney prob for:\",numlines,\" 1% is:\",percent_1))\n               k <- 1\n               m <- 1\n               \n               nic1 <- proc.time()\n               \n               for (i in 1:numlines) {\n                 t1 <- as.character(DT.tri.prob[i,t1,])\n                 t2 <- as.character(DT.tri.prob[i,t2,])\n                 t3 <- as.character(DT.tri.prob[i,t3,])\n                 prob_kneser_ney(c(t1,t2,t3))\n                 \n                 ### To give some feedback, print a message each 1%\n                 if (k==percent_1) {\n                   nic2 <- proc.time()\n                   print(paste(\"......\",m,\"% done in \",\n                               elapsed_time(nic1,nic2),\" seconds ...\",sep=\"\"))\n                   #save_DT_prob_temp(n,lines)\n                   \n                   k <- 1\n                   m <- m + 1\n                 } else { k <- k + 1}\n                 #print(paste(\" i:\",i,\" total:\",numlines,\" percent1:\",percent_1,\" k:\",k,\" m:\",m))\n               }\n               save_DT_prob_temp(n,lines)\n               # Clean the DT with only four columns (t1,t2,t3,prob)\n               DT.tri.prob.final <<- DT.tri.prob[,list(t1,t2,t3,pkn1),]\n               DT.tri.prob.final[,prob:=pkn1,]\n               DT.tri.prob.final <<- DT.tri.prob.final[,list(t1,t2,t3,prob),]\n               rm(DT.tri.prob,envir =.GlobalEnv)\n               \n               print(paste(\"Saving DT probability final file:\",file.name.final,sep=\"\"))\n               save(DT.tri.prob.final,file=file.name.final)\n             },\n             \"4\" = {\n               ## For each quadgram lets calculate the kneser-ney prob\n               \n               if (numlines == -1) { numlines <- nrow(DT.quad.prob) }\n               \n               percent_1 <- round(numlines/100)\n               print(paste(\"... Calculating Knersey-ney prob for:\",numlines,\" 1% is:\",percent_1))\n               k <- 1\n               m <- 1\n               \n               nic1 <- proc.time()\n               \n               for (i in 1:numlines) {\n                 t1 <- as.character(DT.quad.prob[i,t1,])\n                 t2 <- as.character(DT.quad.prob[i,t2,])\n                 t3 <- as.character(DT.quad.prob[i,t3,])\n                 t4 <- as.character(DT.quad.prob[i,t4,])\n                 prob_kneser_ney(c(t1,t2,t3,t4))\n                 \n                 ### To give some feedback, print a message each 10%\n                 if (k==percent_1) {\n                   nic2 <- proc.time()\n                   \n                   print(paste(\"......\",m,\"% done in \",\n                               elapsed_time(nic1,nic2),\" seconds ...\",sep=\"\"))\n                   #save_DT_prob_temp(n,lines)\n                   \n                   k <- 1\n                   m <- m + 1\n                 } else { k <- k + 1}\n                 #print(paste(\" i:\",i,\" total:\",numlines,\" percent1:\",percent_1,\" k:\",k,\" m:\",m))\n               }\n              \n               save_DT_prob_temp(n,lines)\n               # Clean the DT with only five columns (t1,t2,t3,t4,prob)\n               DT.quad.prob.final <<- DT.quad.prob[,list(t1,t2,t3,t4,pkn1),]\n               DT.quad.prob.final[,prob:=pkn1,]\n               DT.quad.prob.final <<- DT.quad.prob.final[,list(t1,t2,t3,t4,prob),]\n               rm(DT.quad.prob,envir =.GlobalEnv)\n               \n               print(paste(\"... Saving DT probability final file:\",file.name.final,sep=\"\"))\n               save(DT.quad.prob.final,file=file.name.final)\n             \n               \n             }\n      )\n      tic2 <- proc.time()\n      print(paste(\"-----> calculate_prob_kn: Running Time .......\",\n                  elapsed_time(tic1,tic2),\" seconds ...\",sep=\"\"))\n    }\n  }\n}",
    "created" : 1467291401146.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2211926141",
    "id" : "76D661D0",
    "lastKnownWriteTime" : 1467385490,
    "last_content_update" : 1467385490122,
    "path" : "D:/Coursera/Capstone Project/Coursera---Data-Science---Capstone-Project/Knersey-ney vFinal.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}